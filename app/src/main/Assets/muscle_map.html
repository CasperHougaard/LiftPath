<!DOCTYPE html>
<!--
    REUSABLE MUSCLE MAP COMPONENT
    
    This HTML file can be reused in any Activity's XML layout that includes a WebView.
    
    Setup:
    1. Add this HTML file to app/src/main/assets/
    2. Add the SVG file (liftpath_musclegroups.svg) to app/src/main/assets/
    3. Load this HTML in your WebView:
       webView.loadUrl("file:///android_asset/muscle_map.html")
    
    Usage from Kotlin:
    - Call JavaScript: setHighlights(primaryArray, secondaryArray)
    - primaryArray: Array of muscle IDs (e.g., ['CHEST_UPPER', 'CHEST_MIDDLE'])
    - secondaryArray: Array of muscle IDs (e.g., ['CHEST_LOWER'])
    - Colors: Primary = dark blue (#1E40AF), Secondary = light blue (#60A5FA), Default = gray (#444444)
    
    Features:
    - Automatically creates gray overlays for all muscles on load
    - Changes overlay colors when muscles are selected
    - Works with any SVG element type (ellipse, use, path, rect, g)
-->
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background: transparent;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }
        * {
            box-sizing: border-box;
        }
        #svg-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        svg {
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            margin: 0 auto;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* DEFAULT STATE: Dark Grey with White Outline */
        /* Exclude overlays from default styling */
        path:not([id*="_overlay"]) {
            fill: #444444 !important;
            stroke: #ffffff !important;
            stroke-width: 2px !important;
            transition: fill 0.3s ease;
        }

        /* DEFAULT STATE for <use> elements */
        use {
            fill: #444444 !important;
            fill-opacity: 1.0 !important;
            stroke: #ffffff !important;
            stroke-width: 2px !important;
            transition: fill 0.3s ease;
        }
        
        /* CRITICAL: Overlays should NOT be affected by default styling - let JavaScript control them */
        [id*="_overlay"] {
            /* No default styling - JavaScript sets all properties */
            transition: fill 0.3s ease, fill-opacity 0.3s ease;
        }
        
        /* Default state for ellipse elements (exclude overlays) */
        ellipse:not([id*="_overlay"]) {
            fill: #444444 !important;
            stroke: #ffffff !important;
            stroke-width: 2px !important;
            transition: fill 0.3s ease;
        }
    </style>
</head>
<body>

    <!-- Container where SVG will be injected -->
    <div id="svg-container"></div>

    <script>
        // Load the SVG immediately using fetch (works with allowFileAccessFromFileURLs)
        fetch('liftpath_musclegroups.svg')
            .then(response => response.text())
            .then(svgText => {
                // Inject the raw XML into the DIV
                const container = document.getElementById('svg-container');
                container.innerHTML = svgText;
                
                // Setup SVG after injection
                const svg = container.querySelector('svg');
                if (svg) {
                    // Set preserveAspectRatio to maintain aspect ratio and center
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    
                    console.log('SVG loaded successfully into main document');
                    
                    // Log available IDs for debugging
                    const allIds = [];
                    document.querySelectorAll('[id]').forEach(el => {
                        allIds.push(el.id);
                    });
                    console.log('Available IDs:', allIds);
                    
                    // Check for missing muscle IDs and report to Kotlin
                    checkMissingMuscleIds(svg);
                    
                    // Initialize: Create gray overlays for all muscle elements
                    initializeMuscleOverlays(svg);
                }
            })
            .catch(err => {
                console.error('Failed to load SVG:', err);
                // Fallback to XMLHttpRequest if fetch fails
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'liftpath_musclegroups.svg', true);
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 0)) {
                        const container = document.getElementById('svg-container');
                        container.innerHTML = xhr.responseText;
                        const svg = container.querySelector('svg');
                        if (svg) {
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                            svg.setAttribute('width', '100%');
                            svg.setAttribute('height', '100%');
                            // Initialize: Create gray overlays for all muscle elements
                            initializeMuscleOverlays(svg);
                        }
                    }
                };
                xhr.send(null);
            });

        // Kotlin calls this function: setHighlights(primaryArray, secondaryArray)
        // primaryArray: ['CHEST_UPPER'] - uses dark blue (#1E40AF)
        // secondaryArray: ['CHEST_LOWER'] - uses light blue (#60A5FA)
        // Make it globally accessible
        // Track created overlays so we can reliably remove them
        if (!window.muscleMapOverlays) {
            window.muscleMapOverlays = new Set(); // Track overlay IDs we've created
        }
        
        // Color definitions
        const COLOR_PRIMARY = '#1E40AF';      // Dark blue for primary muscles
        const COLOR_SECONDARY = '#60A5FA';    // Light blue for secondary muscles
        const COLOR_DEFAULT = '#444444';      // Default gray
        
        // Helper function to create overlay for any muscle element
        // Works with ellipse, use, path, rect, g, etc. - matches the original shape!
        function createMuscleOverlay(muscleElement, overlayColor, docContext) {
            const id = muscleElement.id;
            if (!id) return null;
            
            // Use provided document context or fall back to global document
            const doc = docContext || document;
            
            const overlayId = id + '_overlay';
            const tagName = muscleElement.tagName.toLowerCase();
            
            let overlay;
            
            // Create overlay element matching the original shape
            if (tagName === 'ellipse') {
                // For ellipse, create an ellipse overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                overlay.setAttribute('cx', muscleElement.getAttribute('cx') || '0');
                overlay.setAttribute('cy', muscleElement.getAttribute('cy') || '0');
                overlay.setAttribute('rx', muscleElement.getAttribute('rx') || '50');
                overlay.setAttribute('ry', muscleElement.getAttribute('ry') || '50');
            } else if (tagName === 'circle') {
                // For circle, create a circle overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'circle');
                overlay.setAttribute('cx', muscleElement.getAttribute('cx') || '0');
                overlay.setAttribute('cy', muscleElement.getAttribute('cy') || '0');
                overlay.setAttribute('r', muscleElement.getAttribute('r') || '50');
            } else if (tagName === 'path') {
                // For path, clone the path element
                overlay = muscleElement.cloneNode(false); // Clone without children
                // Remove ALL identifying attributes to prevent overlay from being found as muscle
                overlay.removeAttribute('id');
                overlay.removeAttributeNS('http://www.serif.com/', 'id');
                overlay.removeAttribute('serif:id');
                overlay.removeAttribute('serif\\:id');
                // Remove any inline fill/style that might interfere with our overlay color
                overlay.removeAttribute('fill');
                overlay.removeAttribute('style');
                // Keep the path data (d attribute) - that's what defines the shape
            } else if (tagName === 'rect') {
                // For rect, create a rect overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                overlay.setAttribute('x', muscleElement.getAttribute('x') || '0');
                overlay.setAttribute('y', muscleElement.getAttribute('y') || '0');
                overlay.setAttribute('width', muscleElement.getAttribute('width') || '100');
                overlay.setAttribute('height', muscleElement.getAttribute('height') || '100');
            } else if (tagName === 'use') {
                // For use, create overlay matching the referenced element's bounding box
                // We'll use a path that matches the bounding box shape
                try {
                    const bbox = muscleElement.getBBox();
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${bbox.x} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y + bbox.height} L ${bbox.x} ${bbox.y + bbox.height} Z`;
                    overlay.setAttribute('d', pathData);
                } catch (e) {
                    // Fallback to rect if getBBox fails
                    const x = muscleElement.getAttribute('x') || '0';
                    const y = muscleElement.getAttribute('y') || '0';
                    const width = muscleElement.getAttribute('width') || '100';
                    const height = muscleElement.getAttribute('height') || '100';
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    overlay.setAttribute('x', x);
                    overlay.setAttribute('y', y);
                    overlay.setAttribute('width', width);
                    overlay.setAttribute('height', height);
                }
            } else {
                // For other shapes (polygon, polyline, g, etc.), try to get bounding box
                // and create a path that matches it, or fall back to rect
                try {
                    const bbox = muscleElement.getBBox();
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${bbox.x} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y + bbox.height} L ${bbox.x} ${bbox.y + bbox.height} Z`;
                    overlay.setAttribute('d', pathData);
                } catch (e) {
                    // Final fallback: create a rect overlay
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    try {
                        const bbox = muscleElement.getBBox();
                        overlay.setAttribute('x', bbox.x);
                        overlay.setAttribute('y', bbox.y);
                        overlay.setAttribute('width', bbox.width);
                        overlay.setAttribute('height', bbox.height);
                    } catch (e2) {
                        // Absolute last resort
                        overlay.setAttribute('x', '0');
                        overlay.setAttribute('y', '0');
                        overlay.setAttribute('width', '100');
                        overlay.setAttribute('height', '100');
                    }
                }
            }
            
            // Copy transform if exists (important for positioning)
            const transform = muscleElement.getAttribute('transform');
            if (transform) {
                overlay.setAttribute('transform', transform);
            }
            
            // Set overlay properties - CRITICAL: Remove style attribute FIRST, then set our properties
            overlay.removeAttribute('style'); // Remove any inline styles that might override our colors
            overlay.setAttribute('id', overlayId);
            overlay.setAttribute('fill', overlayColor);
            overlay.setAttribute('fill-opacity', '0.9'); // Higher opacity for better visibility
            overlay.setAttribute('stroke', 'none');
            overlay.setAttribute('stroke-width', '0');
            overlay.setAttribute('pointer-events', 'none');
            
            // Ensure overlay doesn't have any serif:id attribute that could cause it to be found as a muscle
            // (clean up any that might have been copied during cloning)
            overlay.removeAttributeNS('http://www.serif.com/', 'id');
            overlay.removeAttribute('serif:id');
            overlay.removeAttribute('serif\\:id');
            
            return overlay;
        }
        
        // Helper function to find all elements that match a muscle name
        // Handles: exact ID match (including duplicates), serif:id attribute match, and numbered variants
        // IMPORTANT: Excludes overlay elements (anything ending in '_overlay')
        function findAllMuscleElements(muscleName, doc) {
            const matches = [];
            const matchedElements = new Set(); // Track elements we've already added to avoid duplicates
            
            // Helper to check if an ID is an overlay element
            function isOverlayElement(id) {
                return id && id.endsWith('_overlay');
            }
            
            // Iterate through ALL elements with IDs once, checking all matching criteria
            // This handles duplicate IDs correctly by checking each element individually
            const allElementsWithId = doc.querySelectorAll('[id]');
            allElementsWithId.forEach(el => {
                // Skip overlay elements - they should never be treated as muscle elements
                if (isOverlayElement(el.id)) {
                    return;
                }
                
                // Skip if already matched (tracked by element reference, handles duplicate IDs)
                if (matchedElements.has(el)) {
                    return;
                }
                
                // 1. Check for exact ID match (handles duplicate IDs - finds ALL elements with same ID)
                if (el.id === muscleName) {
                    matches.push(el);
                    matchedElements.add(el);
                    return;
                }
                
                // 2. Check serif:id attribute (namespace-aware or as regular attribute)
                const serifId = el.getAttributeNS('http://www.serif.com/', 'id') || 
                               el.getAttribute('serif:id') ||
                               el.getAttribute('serif\\:id');
                
                if (serifId === muscleName) {
                    matches.push(el);
                    matchedElements.add(el);
                    return;
                }
                
                // 3. Find numbered variants (e.g., CHEST_MIDDLE1, CHEST_MIDDLE2, etc.)
                // Pattern: muscleName followed by one or more digits
                if (el.id) {
                    const numberedPattern = new RegExp('^' + muscleName + '\\d+$');
                    if (numberedPattern.test(el.id)) {
                        matches.push(el);
                        matchedElements.add(el);
                    }
                }
            });
            
            return matches;
        }
        
        // Check for missing muscle IDs from the enum
        // This function should be called after SVG loads to verify all muscles exist
        window.checkMissingMuscleIds = function(expectedMuscleIds, docContext) {
            const doc = docContext || document;
            const missingIds = [];
            const foundIds = [];
            
            // Get all IDs from the SVG (excluding overlays)
            const allElementsWithId = doc.querySelectorAll('[id]');
            const svgIds = new Set();
            const allOverlayIds = new Set();
            
            allElementsWithId.forEach(el => {
                const id = el.id;
                if (id && id.endsWith('_overlay')) {
                    allOverlayIds.add(id);
                } else if (id && !id.startsWith('_Image') && id !== 'svg-container') {
                    svgIds.add(id);
                }
            });
            
            // Check each expected muscle ID
            expectedMuscleIds.forEach(muscleId => {
                let found = false;
                let foundAs = '';
                
                // Check if exact match exists
                if (svgIds.has(muscleId)) {
                    found = true;
                    foundAs = muscleId;
                    foundIds.push(muscleId);
                }
                
                // Check if numbered variant exists (e.g., CHEST_MIDDLE1)
                if (!found) {
                    svgIds.forEach(svgId => {
                        const numberedPattern = new RegExp('^' + muscleId + '\\d+$');
                        if (numberedPattern.test(svgId)) {
                            found = true;
                            foundAs = svgId;
                            foundIds.push(muscleId + ' (found as ' + svgId + ')');
                        }
                    });
                }
                
                // Check if serif:id attribute matches
                if (!found) {
                    allElementsWithId.forEach(el => {
                        if (isOverlayElement(el.id)) return;
                        const serifId = el.getAttributeNS('http://www.serif.com/', 'id') || 
                                       el.getAttribute('serif:id') ||
                                       el.getAttribute('serif\\:id');
                        if (serifId === muscleId) {
                            found = true;
                            foundAs = el.id + ' (via serif:id)';
                            foundIds.push(muscleId + ' (found via serif:id in ' + el.id + ')');
                        }
                    });
                }
                
                // If still not found, it's missing
                if (!found) {
                    missingIds.push(muscleId);
                }
            });
            
            // Log results
            const result = {
                missing: missingIds,
                found: foundIds,
                totalExpected: expectedMuscleIds.length,
                totalFound: foundIds.length,
                totalMissing: missingIds.length,
                allSvgIds: Array.from(svgIds).sort()
            };
            
            console.log('=== MUSCLE ID CHECK ===');
            console.log('Total expected muscles:', expectedMuscleIds.length);
            console.log('Total found:', foundIds.length);
            console.log('Total missing:', missingIds.length);
            
            if (missingIds.length > 0) {
                console.warn('⚠️⚠️⚠️ MISSING MUSCLE IDs in SVG: ' + missingIds.join(', '));
                console.warn('Expected ' + expectedMuscleIds.length + ' muscles, but ' + missingIds.length + ' are missing from the SVG file!');
            } else {
                console.log('✓ All ' + expectedMuscleIds.length + ' muscle IDs found in SVG!');
            }
            
            console.log('Found IDs: ' + foundIds.join(','));
            console.log('All SVG IDs (non-overlay): ' + Array.from(svgIds).sort().join(','));
            
            // Log a summary
            console.log('--- SUMMARY ---');
            console.log('Expected muscles: ' + expectedMuscleIds.length);
            console.log('Found in SVG: ' + foundIds.length);
            console.log('Missing from SVG: ' + missingIds.length);
            
            // Explicitly list missing muscles
            if (missingIds.length > 0) {
                console.error('❌ MISSING MUSCLES FROM SVG:');
                missingIds.forEach(muscleId => {
                    console.error('   - ' + muscleId + ' (NOT FOUND in SVG)');
                });
                console.error('⚠️  ACTION REQUIRED: Add these muscle IDs to liftpath_musclegroups.svg');
            } else {
                console.log('✅ All muscles found! No missing IDs.');
            }
            
            // List all expected for reference
            console.log('--- ALL EXPECTED MUSCLES ---');
            expectedMuscleIds.forEach(muscleId => {
                const isFound = !missingIds.includes(muscleId);
                console.log('  ' + (isFound ? '✓' : '✗') + ' ' + muscleId);
            });
            console.log('========================');
            
            return JSON.stringify(result);
        };
        
        // Helper function used by checkMissingMuscleIds
        function isOverlayElement(id) {
            return id && id.endsWith('_overlay');
        }
        
        // Initialize all muscles with gray overlays
        function initializeMuscleOverlays(svg) {
            if (!svg) return;
            
            const doc = svg.ownerDocument || document;
            const allElements = doc.querySelectorAll('[id]');
            
            allElements.forEach(el => {
                const id = el.id;
                // Skip overlays, images, and container IDs
                if (id.endsWith('_overlay') || id.startsWith('_Image') || id === 'svg-container') {
                    return;
                }
                
                // Check if this is a muscle element (has an ID that could be a muscle)
                // We'll create overlay for any element with an ID that might be a muscle
                const overlayId = id + '_overlay';
                
                // Only create if overlay doesn't exist
                if (!doc.getElementById(overlayId)) {
                    const overlay = createMuscleOverlay(el, COLOR_DEFAULT, doc);
                    if (overlay && el.parentNode) {
                        // Insert after the muscle element
                        const nextSibling = el.nextSibling;
                        if (nextSibling) {
                            el.parentNode.insertBefore(overlay, nextSibling);
                        } else {
                            el.parentNode.appendChild(overlay);
                        }
                        // Track this overlay
                        if (!window.muscleMapOverlays) {
                            window.muscleMapOverlays = new Set();
                        }
                        window.muscleMapOverlays.add(overlayId);
                        console.log('Created gray overlay for:', id);
                    }
                }
            });
        }
        
        window.setHighlights = function(primaryArray, secondaryArray) {
            // Handle old single-array format for backwards compatibility
            if (!secondaryArray && Array.isArray(primaryArray)) {
                secondaryArray = [];
            } else if (!secondaryArray) {
                secondaryArray = [];
                primaryArray = [];
            }
            if (!primaryArray) {
                primaryArray = [];
            }
            
            console.log('=== setHighlights START ===');
            console.log('Called with primary:', JSON.stringify(primaryArray), 'secondary:', JSON.stringify(secondaryArray));
            
            let debugMessages = [];
            debugMessages.push('START: primary=' + JSON.stringify(primaryArray) + ' secondary=' + JSON.stringify(secondaryArray));
            
            try {
                // Try to find SVG in main document first (where fetch loads it)
                let doc = document;
                let svgLoaded = document.querySelector('svg');
                
                // If not found in main document, try object tag (like test button does)
                if (!svgLoaded) {
                    debugMessages.push('SVG not in main document, trying object tag...');
                    console.log('SVG not in main document, trying object tag...');
                    const svgObject = document.getElementById('svg-object');
                    if (svgObject) {
                        try {
                            const svgDoc = svgObject.contentDocument;
                            if (svgDoc) {
                                doc = svgDoc;
                                svgLoaded = svgDoc.querySelector('svg');
                                debugMessages.push('Using svgDoc from object');
                                console.log('Using svgDoc from object');
                            }
                        } catch (e) {
                            debugMessages.push('Cannot access svgDoc: ' + e.message);
                            console.log('Cannot access svgDoc:', e);
                        }
                    }
                } else {
                    debugMessages.push('Using main document');
                    console.log('Using main document');
                }
                
                if (!svgLoaded) {
                    debugMessages.push('SVG not ready, retrying in 100ms...');
                    console.log('SVG not ready, retrying in 100ms...');
                    setTimeout(() => window.setHighlights(primaryArray, secondaryArray), 100);
                    window.setHighlights._lastDebug = debugMessages.join(' | ');
                    return 'RETRY: SVG not ready yet | ' + debugMessages.join(' | ');
                }
                
                debugMessages.push('SVG is loaded, using: ' + (doc === document ? 'main' : 'svgDoc'));
                console.log('SVG is loaded, using document:', doc === document ? 'main' : 'svgDoc');
            
                // 1. RESET LOGIC - Reset all overlays to gray (don't remove, just change color)
                let resetCount = 0;
                
                // Reset all tracked overlays to gray
                if (window.muscleMapOverlays) {
                    window.muscleMapOverlays.forEach(overlayId => {
                        const overlay = doc.getElementById(overlayId);
                        if (overlay) {
                            overlay.setAttribute('fill', COLOR_DEFAULT);
                            overlay.setAttribute('fill-opacity', '0.7');
                            resetCount++;
                        } else {
                            // Overlay not found, remove from tracking
                            window.muscleMapOverlays.delete(overlayId);
                        }
                    });
                }
                
                // Also reset any overlays found by scanning (in case tracking is incomplete)
                // Check for ALL overlay types: rect, ellipse, path, circle, etc.
                const allOverlays = Array.from(doc.querySelectorAll('[id*="_overlay"]'));
                allOverlays.forEach(overlayEl => {
                    const overlayId = overlayEl.id;
                    if (overlayId && overlayId.endsWith('_overlay')) {
                        overlayEl.setAttribute('fill', COLOR_DEFAULT);
                        overlayEl.setAttribute('fill-opacity', '0.7');
                        // Add to tracking if not already there
                        if (window.muscleMapOverlays && !window.muscleMapOverlays.has(overlayId)) {
                            window.muscleMapOverlays.add(overlayId);
                        }
                        resetCount++;
                    }
                });
                
                debugMessages.push('Reset ' + resetCount + ' overlay(s) to gray');
                
                // 2. Reset all muscle element styles (remove any direct styling)
                // The overlays handle the coloring now, but we should reset direct styles too
                doc.querySelectorAll('path, rect, use, ellipse, g').forEach(el => {
                    // Skip overlay rectangles
                    if (el.id && el.id.endsWith('_overlay')) {
                        return;
                    }
                    
                    // Remove highlight classes
                    el.classList.remove('highlighted');
                    el.classList.remove('active');
                    
                    // Reset inline styles if they were set
                    if (el.id) {
                        // Only reset elements with IDs (muscles)
                        el.style.removeProperty('fill');
                        el.style.removeProperty('fill-opacity'); // Reset opacity so original elements show properly
                        el.style.removeProperty('opacity'); // Reset opacity
                        el.style.removeProperty('stroke');
                        el.style.removeProperty('stroke-width');
                    }
                });
                
                // 3. Highlight target muscles
                // Build a map of muscle ID -> color (primary takes precedence)
                const muscleColorMap = new Map();
                
                // Add secondary muscles first (light blue)
                secondaryArray.forEach(id => {
                    muscleColorMap.set(id, COLOR_SECONDARY);
                });
                
                // Add primary muscles (dark blue, will override secondary if same ID)
                primaryArray.forEach(id => {
                    muscleColorMap.set(id, COLOR_PRIMARY);
                });
                
                const allTargets = Array.from(muscleColorMap.keys());
                
                if (allTargets.length > 0) {
                    debugMessages.push('Highlighting ' + allTargets.length + ' muscle(s) - ' + primaryArray.length + ' primary, ' + secondaryArray.length + ' secondary');
                    console.log('Highlighting', allTargets.length, 'muscle(s)');
                    console.log('Primary:', primaryArray.join(', '));
                    console.log('Secondary:', secondaryArray.join(', '));
                    
                    // Get all available IDs for debugging
                    const allIds = [];
                    doc.querySelectorAll('[id]').forEach(e => allIds.push(e.id));
                    debugMessages.push('Available IDs: ' + allIds.slice(0, 20).join(', ') + (allIds.length > 20 ? '...' : ''));
                    
                    // Track which muscles are successfully processed
                    const processedMuscles = [];
                    const skippedMuscles = [];
                    
                    allTargets.forEach((muscleName, muscleIndex) => {
                        console.log('[' + (muscleIndex + 1) + '/' + allTargets.length + '] Processing:', muscleName);
                        const color = muscleColorMap.get(muscleName);
                        const isPrimary = primaryArray.includes(muscleName);
                        const isSecondary = secondaryArray.includes(muscleName);
                        const role = isPrimary && isSecondary ? 'both (primary)' : (isPrimary ? 'primary' : 'secondary');
                        
                        debugMessages.push('Looking for: ' + muscleName + ' (' + role + ', color: ' + color + ')');
                        console.log('Looking for muscle:', muscleName, 'color:', color);
                        
                        // Find ALL elements that match this muscle name
                        // (exact ID, serif:id match, or numbered variants)
                        const matchingElements = findAllMuscleElements(muscleName, doc);
                        
                        if (matchingElements.length > 0) {
                            debugMessages.push('Found ' + matchingElements.length + ' element(s) for: ' + muscleName);
                            console.log('✓ Found', matchingElements.length, 'element(s) for:', muscleName);
                            processedMuscles.push(muscleName);
                            
                            matchingElements.forEach((el, index) => {
                                const elementId = el.id;
                                
                                // SAFETY CHECK: Never process overlay elements
                                if (!elementId || elementId.endsWith('_overlay')) {
                                    debugMessages.push('  SKIPPING overlay element: ' + elementId);
                                    console.warn('  ⚠ SKIPPING overlay element:', elementId);
                                    return;
                                }
                                
                                const tagName = el.tagName.toLowerCase();
                                
                                // Create overlay ID - use simple format: elementId + '_overlay'
                                // This matches the format used during initialization
                                // Only add index if there are ACTUAL duplicates (same exact ID, not numbered variants)
                                let overlayId = elementId + '_overlay';
                                
                                // Check if there are actual duplicate IDs (multiple elements with exact same ID)
                                const elementsWithSameId = matchingElements.filter(e => e.id === elementId);
                                if (elementsWithSameId.length > 1) {
                                    // Actual duplicates - need unique overlay IDs
                                    overlayId = elementId + '_overlay_' + index;
                                }
                                
                                debugMessages.push('  Processing: ' + elementId + ' (' + tagName + ') -> overlay: ' + overlayId);
                                console.log('  Processing element:', elementId, tagName, '-> overlay:', overlayId);
                                
                                // Find or update overlay for this muscle element
                                let overlay = doc.getElementById(overlayId);
                                
                                // If overlay not found and we're dealing with actual duplicate IDs, try finding by position
                                if (!overlay && elementsWithSameId.length > 1) {
                                    // Try to find existing overlay by checking all overlays for this element
                                    const allOverlays = doc.querySelectorAll('#' + elementId.replace(/[#.]/g, '\\$&') + '_overlay, [id^="' + elementId + '_overlay"]');
                                    if (allOverlays.length > index) {
                                        overlay = allOverlays[index];
                                    }
                                }
                                
                                if (overlay) {
                                    // Overlay exists - remove any style attributes first, then set color
                                    overlay.removeAttribute('style'); // CRITICAL: Remove any inline styles that might override
                                    overlay.setAttribute('fill', color);
                                    overlay.setAttribute('fill-opacity', '0.9'); // Higher opacity for better visibility
                                    overlay.setAttribute('stroke', 'none');
                                    overlay.setAttribute('stroke-width', '0');
                                    // Ensure overlay is visible and on top
                                    overlay.setAttribute('pointer-events', 'none');
                                    
                                    // Force visibility via inline styles (can't be overridden by CSS)
                                    overlay.style.setProperty('display', 'block', 'important');
                                    overlay.style.setProperty('visibility', 'visible', 'important');
                                    overlay.style.setProperty('opacity', '1', 'important');
                                    overlay.style.setProperty('fill', color, 'important');
                                    overlay.style.setProperty('fill-opacity', '0.9', 'important');
                                    
                                    // Move overlay to end of parent to ensure it's on top (last in DOM = renders on top in SVG)
                                    if (overlay.parentNode) {
                                        overlay.parentNode.appendChild(overlay);
                                    }
                                    
                                    // Hide the original element fill completely so overlay shows through clearly
                                    // This ensures the colored overlay is the only visible fill
                                    el.style.setProperty('fill', 'none', 'important');
                                    el.style.setProperty('fill-opacity', '0', 'important');
                                    // Keep stroke if it exists for outline, but make it very subtle
                                    if (el.getAttribute('stroke')) {
                                        el.style.setProperty('stroke-opacity', '0.3', 'important');
                                    }
                                    
                                    debugMessages.push('    ✓ Updated overlay color for: ' + elementId + ' (overlay: ' + overlayId + ') to ' + color);
                                    console.log('    ✓ Updated overlay color for:', elementId, '(overlay:', overlayId + ')', 'to', color);
                                } else {
                                    // Overlay doesn't exist - create it (shouldn't happen if initialized properly)
                                    console.warn('    ⚠️ Overlay not found for', elementId, 'with ID:', overlayId, '- creating new one');
                                    // Check if maybe the overlay exists with a slightly different ID
                                    const allOverlays = Array.from(doc.querySelectorAll('[id*="' + elementId + '_overlay"]'));
                                    if (allOverlays.length > 0) {
                                        console.warn('    Found', allOverlays.length, 'potential overlay(s) for', elementId + ':', allOverlays.map(o => o.id).join(', '));
                                        // Try to use the first matching overlay
                                        overlay = allOverlays[0];
                                        overlay.setAttribute('fill', color);
                                        overlay.setAttribute('fill-opacity', '0.7');
                                        debugMessages.push('    ✓ Used existing overlay with different ID for: ' + elementId);
                                        console.log('    ✓ Used existing overlay for:', elementId);
                                    } else {
                                        // Create new overlay
                                        overlay = createMuscleOverlay(el, color, doc);
                                        if (overlay && el.parentNode) {
                                            overlay.setAttribute('id', overlayId); // Ensure it has the correct ID
                                            overlay.setAttribute('pointer-events', 'none');
                                            const nextSibling = el.nextSibling;
                                            if (nextSibling) {
                                                el.parentNode.insertBefore(overlay, nextSibling);
                                            } else {
                                                el.parentNode.appendChild(overlay);
                                            }
                                            if (!window.muscleMapOverlays) {
                                                window.muscleMapOverlays = new Set();
                                            }
                                            window.muscleMapOverlays.add(overlayId);
                                            debugMessages.push('    ✓ Created overlay for: ' + elementId + ' with ID: ' + overlayId);
                                            console.log('    ✓ Created overlay for:', elementId, 'with ID:', overlayId);
                                        } else {
                                            console.error('    ✗ Failed to create overlay for:', elementId);
                                        }
                                    }
                                }
                                
                                el.classList.add('highlighted');
                            });
                        } else {
                            debugMessages.push('NOT FOUND: ' + muscleName + ' (no matching elements)');
                            console.warn('✗ No elements found for muscle:', muscleName);
                            skippedMuscles.push(muscleName);
                        }
                    });
                    
                    // Summary
                    console.log('=== HIGHLIGHTING SUMMARY ===');
                    console.log('Total muscles to highlight:', allTargets.length);
                    console.log('Successfully processed:', processedMuscles.length, '-', processedMuscles.join(', '));
                    if (skippedMuscles.length > 0) {
                        console.warn('⚠️ Skipped (not found):', skippedMuscles.length, '-', skippedMuscles.join(', '));
                    }
                    console.log('============================');
                    
                    // Force a repaint by briefly toggling display (helps with WebView rendering)
                    setTimeout(() => {
                        const svgEl = doc.querySelector('svg');
                        if (svgEl) {
                            svgEl.style.display = 'none';
                            svgEl.offsetHeight; // Force reflow
                            svgEl.style.display = '';
                        }
                    }, 50);
                } else {
                    debugMessages.push('No IDs provided, only resetting');
                    console.log('No IDs provided, only resetting');
                }
            
                // 4. Force WebView repaint (helps with rendering on some Android versions)
                document.body.style.display = 'none';
                document.body.offsetHeight; // Trigger reflow
                document.body.style.display = '';
                
                debugMessages.push('COMPLETED');
                console.log('=== setHighlights completed');
                
                // Store debug messages so Kotlin can access them
                window.setHighlights._lastDebug = debugMessages.join(' | ');
                return debugMessages.join(' | ');
            } catch (error) {
                const errorMsg = 'ERROR: ' + error.message + ' | Stack: ' + error.stack;
                console.error('ERROR in setHighlights:', error);
                console.error('Stack:', error.stack);
                window.setHighlights._lastDebug = errorMsg;
                return errorMsg;
            }
        };
    </script>
</body>
</html>
