<!DOCTYPE html>
<!--
    REUSABLE MUSCLE MAP COMPONENT
    
    This HTML file can be reused in any Activity's XML layout that includes a WebView.
    
    Setup:
    1. Add this HTML file to app/src/main/assets/
    2. Add the SVG file (liftpath_musclegroups.svg) to app/src/main/assets/
    3. Load this HTML in your WebView:
       webView.loadUrl("file:///android_asset/muscle_map.html")
    
    Usage from Kotlin:
    - Call JavaScript: setHighlights(primaryArray, secondaryArray)
    - primaryArray: Array of muscle IDs (e.g., ['CHEST_UPPER', 'CHEST_MIDDLE'])
    - secondaryArray: Array of muscle IDs (e.g., ['CHEST_LOWER'])
    - Colors: Primary = dark blue (#1E40AF), Secondary = light blue (#60A5FA), Default = gray (#444444)
    
    Features:
    - Automatically creates gray overlays for all muscles on load
    - Changes overlay colors when muscles are selected
    - Works with any SVG element type (ellipse, use, path, rect, g)
-->
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background: transparent;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }
        * {
            box-sizing: border-box;
        }
        #svg-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        svg {
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            margin: 0 auto;
            flex-shrink: 0;
            object-fit: contain;
        }

        /* DEFAULT STATE: Dark Grey with White Outline */
        path {
            fill: #444444 !important;
            stroke: #ffffff !important;
            stroke-width: 2px !important;
            transition: fill 0.3s ease;
        }
        
        /* DEFAULT STATE for <use> elements */
        use {
            fill: #444444 !important;
            fill-opacity: 1.0 !important;
            stroke: #ffffff !important;
            stroke-width: 2px !important;
            transition: fill 0.3s ease;
        }
    </style>
</head>
<body>

    <!-- Container where SVG will be injected -->
    <div id="svg-container"></div>

    <script>
        // Load the SVG immediately using fetch (works with allowFileAccessFromFileURLs)
        fetch('liftpath_musclegroups.svg')
            .then(response => response.text())
            .then(svgText => {
                // Inject the raw XML into the DIV
                const container = document.getElementById('svg-container');
                container.innerHTML = svgText;
                
                // Setup SVG after injection
                const svg = container.querySelector('svg');
                if (svg) {
                    // Set preserveAspectRatio to maintain aspect ratio and center
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    svg.setAttribute('width', '100%');
                    svg.setAttribute('height', '100%');
                    
                    console.log('SVG loaded successfully into main document');
                    
                    // Log available IDs for debugging
                    const allIds = [];
                    document.querySelectorAll('[id]').forEach(el => {
                        allIds.push(el.id);
                    });
                    console.log('Available IDs:', allIds);
                    
                    // Initialize: Create gray overlays for all muscle elements
                    initializeMuscleOverlays(svg);
                }
            })
            .catch(err => {
                console.error('Failed to load SVG:', err);
                // Fallback to XMLHttpRequest if fetch fails
                const xhr = new XMLHttpRequest();
                xhr.open('GET', 'liftpath_musclegroups.svg', true);
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 0)) {
                        const container = document.getElementById('svg-container');
                        container.innerHTML = xhr.responseText;
                        const svg = container.querySelector('svg');
                        if (svg) {
                            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                            svg.setAttribute('width', '100%');
                            svg.setAttribute('height', '100%');
                            // Initialize: Create gray overlays for all muscle elements
                            initializeMuscleOverlays(svg);
                        }
                    }
                };
                xhr.send(null);
            });

        // Kotlin calls this function: setHighlights(primaryArray, secondaryArray)
        // primaryArray: ['CHEST_UPPER'] - uses dark blue (#1E40AF)
        // secondaryArray: ['CHEST_LOWER'] - uses light blue (#60A5FA)
        // Make it globally accessible
        // Track created overlays so we can reliably remove them
        if (!window.muscleMapOverlays) {
            window.muscleMapOverlays = new Set(); // Track overlay IDs we've created
        }
        
        // Color definitions
        const COLOR_PRIMARY = '#1E40AF';      // Dark blue for primary muscles
        const COLOR_SECONDARY = '#60A5FA';    // Light blue for secondary muscles
        const COLOR_DEFAULT = '#444444';      // Default gray
        
        // Helper function to create overlay for any muscle element
        // Works with ellipse, use, path, rect, g, etc. - matches the original shape!
        function createMuscleOverlay(muscleElement, overlayColor, docContext) {
            const id = muscleElement.id;
            if (!id) return null;
            
            // Use provided document context or fall back to global document
            const doc = docContext || document;
            
            const overlayId = id + '_overlay';
            const tagName = muscleElement.tagName.toLowerCase();
            
            let overlay;
            
            // Create overlay element matching the original shape
            if (tagName === 'ellipse') {
                // For ellipse, create an ellipse overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                overlay.setAttribute('cx', muscleElement.getAttribute('cx') || '0');
                overlay.setAttribute('cy', muscleElement.getAttribute('cy') || '0');
                overlay.setAttribute('rx', muscleElement.getAttribute('rx') || '50');
                overlay.setAttribute('ry', muscleElement.getAttribute('ry') || '50');
            } else if (tagName === 'circle') {
                // For circle, create a circle overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'circle');
                overlay.setAttribute('cx', muscleElement.getAttribute('cx') || '0');
                overlay.setAttribute('cy', muscleElement.getAttribute('cy') || '0');
                overlay.setAttribute('r', muscleElement.getAttribute('r') || '50');
            } else if (tagName === 'path') {
                // For path, clone the path element
                overlay = muscleElement.cloneNode(false); // Clone without children
                overlay.removeAttribute('id'); // Remove original ID, we'll set overlay ID
            } else if (tagName === 'rect') {
                // For rect, create a rect overlay
                overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                overlay.setAttribute('x', muscleElement.getAttribute('x') || '0');
                overlay.setAttribute('y', muscleElement.getAttribute('y') || '0');
                overlay.setAttribute('width', muscleElement.getAttribute('width') || '100');
                overlay.setAttribute('height', muscleElement.getAttribute('height') || '100');
            } else if (tagName === 'use') {
                // For use, create overlay matching the referenced element's bounding box
                // We'll use a path that matches the bounding box shape
                try {
                    const bbox = muscleElement.getBBox();
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${bbox.x} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y + bbox.height} L ${bbox.x} ${bbox.y + bbox.height} Z`;
                    overlay.setAttribute('d', pathData);
                } catch (e) {
                    // Fallback to rect if getBBox fails
                    const x = muscleElement.getAttribute('x') || '0';
                    const y = muscleElement.getAttribute('y') || '0';
                    const width = muscleElement.getAttribute('width') || '100';
                    const height = muscleElement.getAttribute('height') || '100';
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    overlay.setAttribute('x', x);
                    overlay.setAttribute('y', y);
                    overlay.setAttribute('width', width);
                    overlay.setAttribute('height', height);
                }
            } else {
                // For other shapes (polygon, polyline, g, etc.), try to get bounding box
                // and create a path that matches it, or fall back to rect
                try {
                    const bbox = muscleElement.getBBox();
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${bbox.x} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y} L ${bbox.x + bbox.width} ${bbox.y + bbox.height} L ${bbox.x} ${bbox.y + bbox.height} Z`;
                    overlay.setAttribute('d', pathData);
                } catch (e) {
                    // Final fallback: create a rect overlay
                    overlay = doc.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    try {
                        const bbox = muscleElement.getBBox();
                        overlay.setAttribute('x', bbox.x);
                        overlay.setAttribute('y', bbox.y);
                        overlay.setAttribute('width', bbox.width);
                        overlay.setAttribute('height', bbox.height);
                    } catch (e2) {
                        // Absolute last resort
                        overlay.setAttribute('x', '0');
                        overlay.setAttribute('y', '0');
                        overlay.setAttribute('width', '100');
                        overlay.setAttribute('height', '100');
                    }
                }
            }
            
            // Copy transform if exists (important for positioning)
            const transform = muscleElement.getAttribute('transform');
            if (transform) {
                overlay.setAttribute('transform', transform);
            }
            
            // Set overlay properties
            overlay.setAttribute('id', overlayId);
            overlay.setAttribute('fill', overlayColor);
            overlay.setAttribute('fill-opacity', '0.7');
            overlay.setAttribute('stroke', 'none');
            overlay.setAttribute('pointer-events', 'none');
            
            return overlay;
        }
        
        // Initialize all muscles with gray overlays
        function initializeMuscleOverlays(svg) {
            if (!svg) return;
            
            const doc = svg.ownerDocument || document;
            const allElements = doc.querySelectorAll('[id]');
            
            allElements.forEach(el => {
                const id = el.id;
                // Skip overlays, images, and container IDs
                if (id.endsWith('_overlay') || id.startsWith('_Image') || id === 'svg-container') {
                    return;
                }
                
                // Check if this is a muscle element (has an ID that could be a muscle)
                // We'll create overlay for any element with an ID that might be a muscle
                const overlayId = id + '_overlay';
                
                // Only create if overlay doesn't exist
                if (!doc.getElementById(overlayId)) {
                    const overlay = createMuscleOverlay(el, COLOR_DEFAULT, doc);
                    if (overlay && el.parentNode) {
                        // Insert after the muscle element
                        const nextSibling = el.nextSibling;
                        if (nextSibling) {
                            el.parentNode.insertBefore(overlay, nextSibling);
                        } else {
                            el.parentNode.appendChild(overlay);
                        }
                        // Track this overlay
                        if (!window.muscleMapOverlays) {
                            window.muscleMapOverlays = new Set();
                        }
                        window.muscleMapOverlays.add(overlayId);
                        console.log('Created gray overlay for:', id);
                    }
                }
            });
        }
        
        window.setHighlights = function(primaryArray, secondaryArray) {
            // Handle old single-array format for backwards compatibility
            if (!secondaryArray && Array.isArray(primaryArray)) {
                secondaryArray = [];
            } else if (!secondaryArray) {
                secondaryArray = [];
                primaryArray = [];
            }
            if (!primaryArray) {
                primaryArray = [];
            }
            
            console.log('=== setHighlights START ===');
            console.log('Called with primary:', JSON.stringify(primaryArray), 'secondary:', JSON.stringify(secondaryArray));
            
            let debugMessages = [];
            debugMessages.push('START: primary=' + JSON.stringify(primaryArray) + ' secondary=' + JSON.stringify(secondaryArray));
            
            try {
                // Try to find SVG in main document first (where fetch loads it)
                let doc = document;
                let svgLoaded = document.querySelector('svg');
                
                // If not found in main document, try object tag (like test button does)
                if (!svgLoaded) {
                    debugMessages.push('SVG not in main document, trying object tag...');
                    console.log('SVG not in main document, trying object tag...');
                    const svgObject = document.getElementById('svg-object');
                    if (svgObject) {
                        try {
                            const svgDoc = svgObject.contentDocument;
                            if (svgDoc) {
                                doc = svgDoc;
                                svgLoaded = svgDoc.querySelector('svg');
                                debugMessages.push('Using svgDoc from object');
                                console.log('Using svgDoc from object');
                            }
                        } catch (e) {
                            debugMessages.push('Cannot access svgDoc: ' + e.message);
                            console.log('Cannot access svgDoc:', e);
                        }
                    }
                } else {
                    debugMessages.push('Using main document');
                    console.log('Using main document');
                }
                
                if (!svgLoaded) {
                    debugMessages.push('SVG not ready, retrying in 100ms...');
                    console.log('SVG not ready, retrying in 100ms...');
                    setTimeout(() => window.setHighlights(primaryArray, secondaryArray), 100);
                    window.setHighlights._lastDebug = debugMessages.join(' | ');
                    return 'RETRY: SVG not ready yet | ' + debugMessages.join(' | ');
                }
                
                debugMessages.push('SVG is loaded, using: ' + (doc === document ? 'main' : 'svgDoc'));
                console.log('SVG is loaded, using document:', doc === document ? 'main' : 'svgDoc');
            
                // 1. RESET LOGIC - Reset all overlays to gray (don't remove, just change color)
                let resetCount = 0;
                
                // Reset all tracked overlays to gray
                if (window.muscleMapOverlays) {
                    window.muscleMapOverlays.forEach(overlayId => {
                        const overlay = doc.getElementById(overlayId);
                        if (overlay) {
                            overlay.setAttribute('fill', COLOR_DEFAULT);
                            overlay.setAttribute('fill-opacity', '0.7');
                            resetCount++;
                        }
                    });
                }
                
                // Also reset any overlays found by scanning (in case tracking is incomplete)
                const allRects = Array.from(doc.querySelectorAll('rect'));
                allRects.forEach(rect => {
                    if (rect.id && rect.id.endsWith('_overlay')) {
                        rect.setAttribute('fill', COLOR_DEFAULT);
                        rect.setAttribute('fill-opacity', '0.7');
                        // Add to tracking if not already there
                        if (window.muscleMapOverlays && !window.muscleMapOverlays.has(rect.id)) {
                            window.muscleMapOverlays.add(rect.id);
                        }
                        resetCount++;
                    }
                });
                
                debugMessages.push('Reset ' + resetCount + ' overlay(s) to gray');
                
                // 2. Reset all muscle element styles (remove any direct styling)
                // The overlays handle the coloring now, but we should reset direct styles too
                doc.querySelectorAll('path, rect, use, ellipse, g').forEach(el => {
                    // Skip overlay rectangles
                    if (el.id && el.id.endsWith('_overlay')) {
                        return;
                    }
                    
                    // Remove highlight classes
                    el.classList.remove('highlighted');
                    el.classList.remove('active');
                    
                    // Reset inline styles if they were set
                    if (el.id) {
                        // Only reset elements with IDs (muscles)
                        el.style.removeProperty('fill');
                        el.style.removeProperty('fill-opacity');
                        el.style.removeProperty('stroke');
                        el.style.removeProperty('stroke-width');
                    }
                });
                
                // 3. Highlight target muscles
                // Build a map of muscle ID -> color (primary takes precedence)
                const muscleColorMap = new Map();
                
                // Add secondary muscles first (light blue)
                secondaryArray.forEach(id => {
                    muscleColorMap.set(id, COLOR_SECONDARY);
                });
                
                // Add primary muscles (dark blue, will override secondary if same ID)
                primaryArray.forEach(id => {
                    muscleColorMap.set(id, COLOR_PRIMARY);
                });
                
                const allTargets = Array.from(muscleColorMap.keys());
                
                if (allTargets.length > 0) {
                    debugMessages.push('Highlighting ' + allTargets.length + ' muscle(s) - ' + primaryArray.length + ' primary, ' + secondaryArray.length + ' secondary');
                    console.log('Highlighting', allTargets.length, 'muscle(s)');
                    
                    // Get all available IDs for debugging
                    const allIds = [];
                    doc.querySelectorAll('[id]').forEach(e => allIds.push(e.id));
                    debugMessages.push('Available IDs: ' + allIds.slice(0, 20).join(', ') + (allIds.length > 20 ? '...' : ''));
                    
                    allTargets.forEach(id => {
                        const color = muscleColorMap.get(id);
                        const isPrimary = primaryArray.includes(id);
                        const isSecondary = secondaryArray.includes(id);
                        const role = isPrimary && isSecondary ? 'both (primary)' : (isPrimary ? 'primary' : 'secondary');
                        
                        debugMessages.push('Looking for: ' + id + ' (' + role + ', color: ' + color + ')');
                        console.log('Looking for element with id:', id, 'color:', color);
                        const el = doc.getElementById(id);
                        if (el) {
                            const tagName = el.tagName.toLowerCase();
                            debugMessages.push('Found: ' + id + ' (' + tagName + ')');
                            console.log('✓ Found element:', el.tagName, el.id, 'color:', color);
                            
                            // Handle different element types
                            
                            // Handle any element type using overlays
                            // Find or update overlay for this muscle
                            const overlayId = id + '_overlay';
                            let overlay = doc.getElementById(overlayId);
                            
                            if (overlay) {
                                // Overlay exists - just change its color
                                overlay.setAttribute('fill', color);
                                overlay.setAttribute('fill-opacity', '0.7');
                                debugMessages.push('Updated overlay color for: ' + id + ' to ' + color);
                                console.log('  ✓ Updated overlay color for:', id, 'to', color);
                            } else {
                                // Overlay doesn't exist - create it (shouldn't happen if initialized properly)
                                overlay = createMuscleOverlay(el, color, doc);
                                if (overlay && el.parentNode) {
                                    const nextSibling = el.nextSibling;
                                    if (nextSibling) {
                                        el.parentNode.insertBefore(overlay, nextSibling);
                                    } else {
                                        el.parentNode.appendChild(overlay);
                                    }
                                    if (!window.muscleMapOverlays) {
                                        window.muscleMapOverlays = new Set();
                                    }
                                    window.muscleMapOverlays.add(overlayId);
                                    debugMessages.push('Created overlay for: ' + id);
                                    console.log('  ✓ Created overlay for:', id);
                                }
                            }
                            
                            el.classList.add('highlighted');
                        } else {
                            debugMessages.push('NOT FOUND: ' + id);
                            console.warn('✗ Element not found with id:', id);
                        }
                    });
                } else {
                    debugMessages.push('No IDs provided, only resetting');
                    console.log('No IDs provided, only resetting');
                }
            
                // 4. Force WebView repaint (helps with rendering on some Android versions)
                document.body.style.display = 'none';
                document.body.offsetHeight; // Trigger reflow
                document.body.style.display = '';
                
                debugMessages.push('COMPLETED');
                console.log('=== setHighlights completed');
                
                // Store debug messages so Kotlin can access them
                window.setHighlights._lastDebug = debugMessages.join(' | ');
                return debugMessages.join(' | ');
            } catch (error) {
                const errorMsg = 'ERROR: ' + error.message + ' | Stack: ' + error.stack;
                console.error('ERROR in setHighlights:', error);
                console.error('Stack:', error.stack);
                window.setHighlights._lastDebug = errorMsg;
                return errorMsg;
            }
        };
    </script>
</body>
</html>
